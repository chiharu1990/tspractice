# Git コマンド

## git clone

`git clone` は「既存のリモートリポジトリ」をローカル環境に複製するコマンド

`git　clone リモートリポジトリのURL` 指定されたリモートリポジトリをローカル環境に複製する

## git branch

`git branch`はローカルブランチの一覧を表示するコマンド

`git branch -r`　リモートブランチの一覧を表示する  
`git branch ブランチ名` 新しいブランチを作成する  
`git branch -d ブランチ名` 指定したブランチを削除する

## git switch

`git switch`はブランチを切り替えるコマンド

`git switch ブランチ名`　指定されたブランチに移動する  
`git switch -c ブランチ名` 現在のブランチから新しいブランチを作成する  
`git switch -c ブランチ名 develop` develop ブランチを派生元として新しいブランチを作成する

## git add

`git add`は更新されたファイルの中身をインデックスに追加するコマンド

`git add ファイル名` 指定したファイルをインデックスに追加する  
`git add .` 変更された全てのファイルをインデックスに追加（その階層のファイルをまとめてインデックスに登録する）  
`git add -A` 新規追加、更新、削除のファイルが対象になる。ファイル名の指定を省略できる。その場合は作業ブランチの全てのファイルが対象になる  
オプションがない場合との違いはファイル名の指定を省略できること  
`git add -u` 更新、削除のファイルが対象になり、新規追加のファイルは対象にならない。ファイル名の省略が可能で、その場合は作業ブランチの全てのファイルが対象になる

`git add -p` はファイルの一部の変更をインデックスに追加したいときのコマンド  
実行すると`Stage this hunk [y,n,q,a,d,e,?]? `が表示され、
`y` はインデックスに追加され、`n`はインデックスへの追加がキャンセルされる。`?`を押すと選択肢の一覧が表示される  
`e`を押すと vim の編集モードに入ることができる。

- -を取り消したい場合 → ‘-‘を空欄に”
- +を取り消したい場合 → その行を消す

コマンド上で`y`や`n`などユーザーが入力して処理を進めることを「インタラクティブモード（対話モード）」という

### git add でフォルダを追加したいとき

空のフォルダは`git add`できないので、新規追加したいフォルダの中にファイルを作成してから`git add`してコミットする必要がある

## git commit

`git commit`はファイルやディレクトリの変更をリポジトリ記録するコマンド  
`git commit`のみを実行すると、vim の編集画面になり、コミットメッセージを入力してからコミットされる

`git commit -m "コミットメッセージ"` コミット時にメッセージを追加する  
`git commit --amend` 直前のコミットが修正される

## git push

`git push`はローカルリポジトリのコミット履歴をリモートリポジトリに送信して更新するコマンド

`git push origin ブランチ名` 指定したブランチをリモートリポジトリ上の同名のブランチに送信する  
現在作業中のブランチ（例:241007-git-note）を追加する場合は、`git push origin 241007-git-note`とする  
`git push origin HEAD`でも作業中のブランチを push することができる。

### git push だけ実行したら

`The current branch 241007-git-note has no upstream branch.`のエラーで push できない。  
これは「上流ブランチがありません」という旨のエラー
上流ブランチとは上の例で言うと`origin/241007-git-note`のこと（リモート追跡ブランチ）  
ローカルブランチと上流ブランチが設定できていないので、エラーになる  
上流ブランチとして設定すると、`git push`するときにリモートリポジトリ名とブランチ名を省略できる(`git push`だけで push できるようになる)  
上流ブランチの設定は`git branch -u <リモートブランチ名>`で設定できる  
また、作業ブランチを最初に push する時に`git push -u origin <ローカルブランチ>`とすることで、上流ブランチを設定することができる  
一度設定すれば、そのあとの push 時は`git push`でブランチ名を入れずに push できる

`-u`は`--set-upstream-to=`と同じ

## git merge

2 つのブランチを 1 つに統合する  
`git merge <統合したいブランチ名>`で統合できる。  
main ブランチと作業用のブランチがあり、作業用のブランチの変更を main ブランチ反映したい時は、

1. main ブランチに移動
2. `git merge <作業用ブランチ>`する

例：作業ブランチ（branchA）で作業中に、main の変更があり、main の変更を作業ブランチに取り込みたい時
![alt text](merge1.png)
`git merge main` で main ブランチの変更を作業ブランチに取り込むことができる
![alt text](merge2.png)

## git pull

リモートリポジトリで起きた変更をローカルリポジトリに反映する  
`pull`は`fetch`と`merge`を合わせたもの  
`git pull <リモートリポジトリ名> <ブランチ名>` でローカルリポジトリの現在のブランチにリモートリポジトリの変更を取り込むことができる。  
main ブランチを pull したいときは、

1. main ブランチに移動
2. `git pull origin main`する

### git fetch

コミット履歴の情報を取得している。  
`git fetch` でリモート追跡ブランチが更新される。この時、ローカルブランチは更新されない。merge することでローカルブランチが更新される。

## git rebase

rebase は、コミットを作り直すことができるコマンドである。  
rebase を使うことで、ログをきれいにしたり、コミットの適用場所を変更したりすることができる。

例えば、作業中のブランチ（branchA とする）で作業中に、main ブランチで変更があった時、main ブランチの最新のコミットから作業中ブランチのコミット履歴を繋げることができる。これにより、コミット履歴を一本化することができる

1. ブランチの基点を変更したいブランチに移動(例の場合だと、branchA に移動)
2. `git rebase <リベース先のブランチ名>` （例の場合だと`git rebase main`）

ただし、rebase をするとコミット ID が書き換わる（新たなコミットとなる）ので、すでにリモートリポジトリに push したコミットをリベースするときは注意が必要である。

### コミット ID が書き換わることで起こりうる問題

- チームメンバーとの同期不一致  
  チームで開発している場合、他のメンバーがすでにリモートの履歴を取得しているとき、rebase によって履歴が異なると、pull や merge の時に競合が発生したり、他メンバーが重複コミットを取り込んでしまうことがある。
- リモートへの強制 push が必要になる  
  rebase 後にリモートリポジトリへプッシュしようとすると、通常の push では履歴が一致しないため、エラーとなる。このため`--force`オプションで強制的に push しなければならず、リモートの履歴を上書きしてしまう危険がある。誤って上書きすると、他の人のコミットが失われたりするリスクがあるため、慎重に操作しなくてはいけない
- 参照ができなくなる  
  特定のコミット ID を使用してバグ修正やレビューの参照を行っている場合、ID が書き換わることですでにレビューしている参照が無効になってしまう

### git merge との違いは何か

`git merge`をすると新たにマージコミットが作成され以下のような履歴になる  
![alt text](merge2.png)
`git rebase`を実行すると、main の最新コミットの後に作業ブランチのコミットが続くようになる。こうすることで、分岐や合流がなく、コミット履歴がきれいになり、ログが見やすくなる
![alt text](rebase3.png)

### git rebase のその他のオプション

`git rebase -i <コミットID>` 複数のコミットをまとめたり、コミットメッセージを修正したり削除することができる  
`<コミットID>`は変更したいコミットのひとつ前のコミット ID を指定する（`HEAD@{n}`の形でも OK）

`git rebase -i <コミットID>`を実行すると以下のような画面になる
![alt text](rebase-i.png)

- `pick` コミットをそのまま使う
- `reword` そのコミットメッセージだけを変更する
  メッセージを変更したいコミットに`reword`を入力
  ![alt text](rebase-i-reword.png)  
  メッセージを編集
  ![alt text](rebase-i-reword2.png)  
  メッセージが書き換わる
  ![alt text](rebase-i-reword3.png)
- `edit` そのコミットに対して変更を加えたい時
- `squash`または`s` そのコミットを前のコミットにまとめる
  コミットをまとめたいコミットに`squash`を入力
  ![alt text](rebase-squash.png)
  コミットメッセージの編集画面になるので、コミットメッセージを編集する
  ![alt text](rebase-squash2.png)
  コミットがまとめられる
  ![alt text](rebase-squash3.png)
- `fixup` または`f` そのコミットを前のコミットにまとめ、メッセージを残さない
- `drop` そのコミットを削除する
  削除したいコミットに`drop`を入力
  ![alt text](rebase-drop.png)
  コミットが削除される
  ![alt text](image.png)

## git reset

`git reset` のみでは、add してステージングまでしたファイルを取り消す（ステージング前の状態に戻す）コマンド  
以下のオプションを使用することで、特定の時点までコミットまで戻すことができる（HEAD を移動する）  
リセットのオプションは大きく 3 種類ある  
`git reset --soft <巻き戻したいコミット位置>` HEAD の位置のみ  
実行後はステージされた状態まで巻き戻る
![alt text](--soft.png)
`git reset --mixed <巻き戻したいコミット位置>` HEAD の位置・ステージ  
実行後はステージされていない状態まで巻き戻る  
また、`git reset <巻き戻したいコミット位置>`も同じ意味である
![alt text](--mixed.png)
`git reset --hard <巻き戻したいコミット位置>` HEAD の位置・ステージ・作業ディレクトリ  
実行後は、作業ディレクトリまで巻き戻る  
![alt text](--hard.png)
ステージもされておらず、作業の履歴も消える

<巻き戻したいコミット位置>は  
`HEAD^` 直前のコミット  
`HEAD@{n}` n 個前のコミット  
`コミットID` そのコミット ID まで巻き戻す

### コミット ID を調べるコマンド

- `git log` 各コミットの ID、メッセージ、作成者、日時などが表示される
  ![alt text](gitlog.png)
- `git log --oneline` コミット ID の短縮版とコミットメッセージが 1 行で表示される簡易版のログ
  ![alt text](gitlog2.png)
- `git reflog`すべての HEAD の履歴を確認することができる
  ![alt text](gitreflog.png)

## git revert

指定したコミットと逆の内容をコミットする  
`git revert <打ち消したいコミットID>`  
例：index.html にテキストを追加してコミット後、別ファイル（index2.html）を追加してコミットした状態で、先に対応した index.html のテキスト変更を取り消したい時

1. `git reflog`を使って該当のコミット ID を調べる
2. `git revert <コミットID>`を実行
3. コミットメッセージの編集画面になるので、何も問題なければ`:wq`で抜ける
   ![alt text](revert1.png)
4. index.html で行った変更が打ち消されたものがコミットされる
   ![alt text](revert2.png)

`git revert`は新たにコミットをするコマンドで、`git reset`のようにコミット履歴を改変することはない。  
履歴を改変しても良い場合は、主にローカルブランチで開発中の時で、すでにリモートリポジトリに push した後に関しては履歴を改変しない revert を使うほうが良い。

## git stash

現在の作業内容を一時的に保存し、作業ディレクトリをクリーンにする  
`git stash save` 作業内容を保存する  
`git stash list` 保存したリストを表示する  
![alt text](stash1.png)
stash@{n}は各スタッシュの個別の名前  
`git stash apply stash@{n}` 復活したいスタッシュの名前を指定して作業内容を復活する  
`git stash drop stash@{n}` スタッシュの削除  
`git stash pop stash@{n}` スタッシュの復活と削除を同時に行う  
また、`git stash apply`のように stash 番号を指定しない場合、一番最後にスタッシュに保存した内容が復活する。

## git status

作業ディレクトリの現在の状態を確認するもの  
`git status`を実行すると以下のように表示される

- On branch → 現在のブランチ名
  ![alt text](status1.png)
- Your branch is up to date with 'origin/branch_name'... → リモートブランチとの同期情報
  ![alt text](status2.png)
- Changes to be committed: → ステージングエリアにある次回コミットで追加される予定のファイル
  ![alt text](status3.png)
- Changes not staged for commit: → 追跡されているファイルの中で変更されているがステージングされていないファイル
  ![alt text](status4.png)
- Untracked files: → 新規作成されたが、git にまだ追跡されていないファイル
  ![alt text](status5.png)

`git status -s` 状態を簡潔に表示する（`-s`は`--short`と同じ）

- `M` 修正されたファイル
- `A` ステージングされた新しいファイル
- `??` 追跡されていないファイル

## git restore

作業ディレクトリ上の編集内容（add する前）を取り消すコマンド  
ステージングの状態を変更することもできる。
`git restore <ファイル名>` を実行することで、作業ディレクトリ上の編集内容を取り消して、直前のコミットの状態に戻す。

- `git restore .` 作業ツリー全体の変更を取り消す場合
- `git restore --staged <ファイル名>` ステージした該当のファイルをステージングエリアから下ろす
- `git restore --staged .` 全てのステージされたファイルの変更をステージングエリアから下ろす
- `git restore --worktree <ファイル名>` 作業ディレクトリの変更内容を取り消し、直前のコミットの状態に戻す
- `git restore --source <コミットID> <ファイル名>` 特定のファイルを特定のコミット時点に戻す

## git cherry-pick

別のブランチから今いるブランチへ、必要なコミットだけを適用することができるコマンド  
cherry-pick を実行すると、取り込みたい内容がそのままコミットされる。
`git cherry-pick <コミットID>`

- `git cherry-pick <コミットID -1> <コミットID -2>` 複数のコミットを取り込みたい場合は、コミット ID を続けて指定していく
- `git cherry-pick -n <コミットID>` コミットせずに作業ディレクトリだけに変更を止める場合は、`-n` オプションを使用する
- `git cherry-pick -e <コミットID>` コミットメッセージを変更する場合、`-e`オプションを使用する
- `git cherry-pick -x <コミットID>` cherry-pick したコミットのコミット ID を明記する

### コンフリクトが発生した場合

cherry-pick を実行中にコンフリクトが発生した場合、コンフリクトを解消後、
`git cherry-pick --continue`で続行する  
変更を取り消したい場合は、`git cherry-pick --abort`で取り消すことができる
